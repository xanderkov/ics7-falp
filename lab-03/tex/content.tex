\chapter{Практические задания}

\begin{enumerate}[wide=0pt]

	\item \textit{Чем принципиально отличаются функции cons, list, append?}

		\begin{lstlisting}
			(setf lst1 '(a b))
			(setf lst2 '(c d))
		\end{lstlisting}

		\textit{Каковы результаты вычисления следующих выражений?}
		\begin{lstlisting}
			(cons lstl lst2)
			(list lst1 lst2)
			(append lst1 lst2)
		\end{lstlisting}

		\begin{itemize}
			\item cons объединяет значения своих аргументов в точечную пару. Если вторым
			аргументом будет передан список, то в результате получится список, в
			котором второй аргумент будет добавлен в начало: ((A B)C D)

			\item list составляет из своих аргументов список: ((A B) (C D))
			\item append создает копию всех аргументов, кроме последнего, т. е списковые
			ячейки. Связываются последними указателями. Результирующее значе-
			ние: (A B C D)
		\end{itemize}


	\item  \textit{Каковы результаты вычисления следующих выражений, и почему?}

	\begin{lstlisting}
		(reverse '(a b c)) 		  --> Nil
		(reverse '(a b (c (d))))  --> Nil
		(reverse '(a)) 			  --> (A)
		(last '(a b c)) 		  --> (C) 
		(last '(a)) 			  --> (A)
		(last '((a b c)))         --> ((a b c))
		(reverse ()) --> Nil
		(reverse '((a b c))) -->  ((A B C))
		(last '(a b (c))) --> ((c))
		(last ()) --> Nil
	\end{lstlisting}

	\item  \textit{Написать, по крайней мере, два варианта функции, 
	которая возвращает
	последний элемент своего списка-аргумента.}

	\begin{lstlisting}
		(defun make-two-list (a b)
			(
				if (< a b)
					(list a b)
					(list b a)
				
			)
		)
	\end{lstlisting}

	\item  \textit{Написать, по крайней мере, два варианта функции, 
	которая возвращает
	свой список аргумент без последнего элемента.}

	\begin{lstlisting}
		(defun is-first-between (first second third)
			(
				if (or 
						(and (> first second) (< first third))
						(and (> first third) (< first second))
				   )
					t
					nil
				
			)
		)
	\end{lstlisting}

	\item  \textit{Напишите функцию swap-first-last, 
	которая переставляет в списке-
	аргументе первый и последний элементы.}
	
		\begin{enumerate}[label=\arabic*)]
			\item (and 'fee 'fie 'foe) --- foe
			\item (or nil 'fie 'foe) --- fie
			\item (and (equal 'abc 'abc) 'yes) --- yes
			\item (or 'fee 'fie 'foe) --- fee
			\item (and nil 'fie 'foe) --- Nil
			\item (or (equal 'abc 'abc) 'yes) --- T
		\end{enumerate}

	\item  \textit{Написать простой вариант игры в кости, в котором бросаются две
	правильные кости. Если сумма выпавших очков равна 7 или 11 —
	выигрыш, если выпало (1,1) или (6,6) — игрок имеет право снова
	бросить кости, во всех остальных случаях ход переходит ко второму
	игроку, но запоминается сумма выпавших очков. Если второй игрок не
	выигрывает абсолютно, то выигрывает тот игрок, у которого большеочков. Результат игры и значения выпавших костей выводить на экран с
	помощью функции print.}

	\begin{lstlisting}
		(defun not-less (x y)
			(
				>= x y
			)
		)
	\end{lstlisting}

	\item  \textit{Написать функцию, которая по своему 
	списку-аргументу lst определяет
	является ли он палиндромом (то есть равны ли lst и (reverse lst)).}
	
		\begin{enumerate}[label=\arabic*)]
			\item (defun pred1 (x) (and (numberp x) (plusp x)))
			\item (defun pred2 (x) (and (plusp x)(numberp x)))
		\end{enumerate}

		Ответ: ошибочен вариант 2. Так как and вычисляет аргументы до тех пор,
		пока не будет ясно, какой ответ надо вернуть. pred2 при первой проверке
		вернет NIL и завршит работы не вызывая plusp.

	\item  \textit{Напишите свои необходимые функции, 
	которые обрабатывают таблицу из
	4-х точечных пар:
	(страна . столица), и возвращают по стране - столицу, а по столице —
	страну.}
	
	\begin{lstlisting}
	(defun x-from-y-to-z (x y z)
	(if (< y x)
		(if (< x z)
			T Nil)
		Nil))
	\end{lstlisting}

	\begin{lstlisting}
	(defun x-from-y-to-z (x y z)
		(cond ((< y x) (cond ((< x z) T) (T Nil))) (T Nil)))
	\end{lstlisting}

	\begin{lstlisting}
	(defun x-from-y-to-z (x y z)
		(and (< y x) (< x z)))
	\end{lstlisting}


	\item  \textit{Напишите функцию, которая умножает на заданное число-аргумент
	первый числовой элемент списка из заданного 3-х элементного списка-
	аргумента, когда
	a) все элементы списка --- числа,
	6) элементы списка -- любые объекты.}

	\begin{lstlisting}
	(defun how_alike (x y)
    (cond ((or (= x y) (equal x y)) 'the_same)
        ((and (oddp x) (oddp y)) 'both_odd)
        ((and (evenp x) (evenp y)) 'both_even)
        (T 'difference)
	))
	\end{lstlisting}


	\begin{lstlisting}
		(defun how_alike (x y)
		(if (if (= x y)
				(equal x y))
			'the_same
			(if (if (oddp x)
				(oddp y))
			'both_odd
			(if (if (evenp x)
				(evenp y))
			'both_even
			'difference
		))))
	\end{lstlisting}


	\begin{lstlisting}
		(defun how_alike (x y)
		(or
			(and (= x y) (equal x y) 'the_same)
			(and (oddp x) (oddp y) 'both_odd)
			(and (evenp x) (evenp y) 'both_even)
			'difference
		))
	\end{lstlisting}



\end{enumerate}
\chapter{Практические задания}

\begin{enumerate}[wide=0pt]

	\item \textit{Напишите функцию, которая уменьшает на 10 все числа из списка-аргумента этой
	функции, проходя по верхнему уровню списковых ячеек. ( * Список смешанный
	структурированный)}

		\begin{lstlisting}
			(setf lst1 '(a b))
			(setf lst2 '(c d))
		\end{lstlisting}



	\item  \textit{Написать функцию которая получает как аргумент список чисел, а возвращает список
	квадратов этих чисел в том же порядке.}

	\begin{lstlisting}
		(reverse '(a b c))        --> Nil

	\end{lstlisting}

	\item  \textit{Напишите функцию, которая умножает на заданное число-аргумент все числа из
	заданного списка-аргумента, когда
	a) все элементы списка --- числа,
	б) элементы списка -- любые объекты.}

	\begin{lstlisting}
		(defun get-last (lst)
			(
				car (last lst)
			)
		)
	\end{lstlisting}



	\item  \textit{Написать функцию, которая по своему списку-аргументу lst определяет является ли он
	палиндромом (то есть равны ли lst и (reverse lst)), для одноуровнего смешанного
	списка.}

	\begin{lstlisting}
		(defun get-last (lst)
			(
				nbutlast lst 1
			)
		)
	\end{lstlisting}


	\item  \textit{Используя функционалы, написать предикат set-equal, который возвращает t, если два
	его множества-аргумента (одноуровневые списки) содержат одни и те же элементы,
	порядок которых не имеет значения.}
	
	\begin{lstlisting}
		(defun swap-first-last (lst)
			(
				nconc 
				(last lst)
				(reverse 
					(cdr 
						(reverse (cdr lst)))
				)
				(list (car lst))
			)
		)
	\end{lstlisting}

	\item  \textit{Напишите функцию, select-between, которая из списка-аргумента, содержащего только
	числа, выбирает только те, которые расположены между двумя указанными числами -
	границами-аргументами и возвращает их в виде списка (упорядоченного по
	возрастанию (+ 2 балла)).}

	\begin{lstlisting}
		(defvar first_player)
		(defvar second_player)
		
		
		(defun bones_throw ()
		
			(print "Enter first bone: ")
			(setq bone1 (read))
			(print "Enter second bone: ")
			(setq bone2 (read))
			(setq ret (list bone1 bone2))
			ret
		
		)

	\end{lstlisting}

	\item  \textit{Написать функцию, вычисляющую декартово произведение двух своих списковаргументов. ( Напомним, что А х В это множество всевозможных пар (a b), где а
	принадлежит А, принадлежит В.)}
	\begin{lstlisting}
		(defun get-without-last-reverse (lst)
			(reverse (cdr (reverse lst)))
		)



		(defun st_check (lst)
			(cond
				(
					(> (length lst) 1)
					(and
						(eq (car lst) (car (reverse lst)))
						(st_check (cdr (get-without-last-reverse lst)))
					)
				)
				(T T)
			)
		)


		(defun palindrom_check (lst)
			(st_check lst)
		)
	\end{lstlisting}

	\item  \textit{Почему так реализовано reduce, в чем причина?
	(reduce \#'+ ()) -> 0 (reduce \#'* ()) -> 1}
	
	\begin{lstlisting}
		(defun countries_capitals (lst name)
			(
				cond 
				(
					(assoc name lst)
					(cdr (assoc name lst))
				)
				(
					(rassoc name lst)
					(car (rassoc name lst))
				)
				(T Nil)
			)
		)
	\end{lstlisting}



	\item  \textit{* Пусть list-of-list список, состоящий из списков. Написать функцию, которая
	вычисляет сумму длин всех элементов list-of-list (количество атомов), т.е. например
	для аргумента
	 ((1 2) (3 4)) -> 4.}

	\begin{lstlisting}
		(defun mult_el_a (n lst)
			(
				cond 
				(
					(and
						(and
							(numberp (car lst))
							(and (numberp (cadr lst)) (numberp (caddr lst)))
						)
						(numberp n)
					)
					(* (car lst) n)
				)
				(T Nil)
			)
		)
	\end{lstlisting}


\end{enumerate}